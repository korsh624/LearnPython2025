'''
1) Строится двоичная запись числа N.
2) К этой записи дописывается (дублируется) последняя цифра.
3) Затем справа дописывается бит чётности: 0, если в двоичном коде
 полученного числа чётное число единиц, и 1, если нечётное.
4) К полученному результату дописывается ещё один бит чётности.
'''
def func(n):
    n=bin(n)[2:]
    n = n + n[-1]
    for i in range(2):
        c = n.count('1')
        if c % 2 == 0:
            n += '0'
        else:
            n += '1'
    res = int(n, 2)
    return res

'''
1) Строится восьмибитная двоичная запись числа N.
2) Все цифры двоичной записи заменяются на противоположные (0 на 1, 1 на 0).
3) Полученное число переводится в десятичную запись.
4) Из нового числа вычитается исходное, полученная разность выводится на экран.
'''
def func1(n):
    bynary = bin(n)[2:].zfill(8)#создаем новуюпеременную из за п.4
    new='' # будем накапливать новую строку
    for s in bynary:
        if s == '1':
            new+='0'
        else:
            new+='1'
    new=int(new, 2)
    return new-n

'''1) Строится двоичная запись числа N.
2) Запись «переворачивается», то есть читается справа налево. 
Если при этом появляются ведущие нули, они отбрасываются.
3) Полученное число переводится в десятичную запись и выводится на экран.
'''
def func2(n):
    n = bin(n)[2:]
    n=n[::-1]
    n=int(n,2)
    return n


'''
1) Строится восьмибитная двоичная запись числа N.
2) Инвертируются все разряды исходного числа, кроме последней единицы и стоящих за ней нулей 
(0 заменяется на 1, 1 на 0).
3) Полученное число переводится в десятичную систему счисления.
point1=5

'''
def func3(n):
    n = bin(n)[2:].zfill(8)
    point1=None
    for i in range(8):#ищем последнюю 1
        if n[i]=='1':
            point1=i
    toinvert=n[:point1]
    noivert=n[point1:]
    invert=''#сюда будем копить новую строку
    for char in toinvert:
        if char=='1':
            invert+='0'
        else:
            invert+='1'
    res=invert+noivert
    return int(res,2)


#Рекурсия
def factorial(n):
    if n==0 or n==1:  # тот случай когда рекурсия не вызывается
        return 1
    else:
        return n*factorial(n-1) # тот случай когда функция вызывает сама ссебя


